.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.08)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Validation::Class 3"
.TH Validation::Class 3 "2011-06-21" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Validation::Class \- Centralized Input Validation For Any Application
.SH "VERSION"
.IX Header "VERSION"
version 0.111720
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use MyApp::Validation;
\&    
\&    my $input = MyApp::Validation\->new(params => $params);
\&    
\&    unless ($input\->validate(\*(Aqfield1\*(Aq, \*(Aqfield2\*(Aq)){
\&        return $input\->errors\->to_string;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Validation::Class is a different approach to data validation, it attempts to
simplify and centralize data validation rules to ensure \s-1DRY\s0 (don't repeat
yourself) code. The primary intent of this module is to provide a simplistic
validation work-flow and promote code (validation) reuse.
.SH "BUILDING A VALIDATION CLASS"
.IX Header "BUILDING A VALIDATION CLASS"
.Vb 1
\&    package MyApp::Validation;
\&    
\&    use Validation::Class qw/field mixin filter/;
\&    use base \*(AqValidation::Class\*(Aq;
\&    
\&    # a validation rule
\&    field \*(Aqlogin\*(Aq  => {
\&        label      => \*(Aquser login\*(Aq,
\&        error      => \*(Aqlogin invalid\*(Aq,
\&        validation => sub {
\&            my ($self, $this, $fields) = @_;
\&            return $this\->{value} eq \*(Aqadmin\*(Aq ? 1 : 0;
\&        }
\&    };
\&    
\&    # a validation rule
\&    field \*(Aqpassword\*(Aq  => {
\&        label         => \*(Aquser password\*(Aq,
\&        error         => \*(Aqpassword invalid\*(Aq,
\&        validation    => sub {
\&            my ($self, $this, $fields) = @_;
\&            return $this\->{value} eq \*(Aqpass\*(Aq ? 1 : 0;
\&        }
\&    };
\&    
\&    1;
.Ve
.SH "USING MIXINS AND GROUPING"
.IX Header "USING MIXINS AND GROUPING"
.Vb 1
\&    package MyApp::Validation;
\&    
\&    use Validation::Class qw/field mixin filter/;
\&    use base \*(AqValidation::Class\*(Aq;
\&    
\&    # a validation rule template
\&    mixin \*(Aqbasic\*(Aq  => {
\&        required   => 1,
\&        min_length => 1,
\&        max_length => 255,
\&        filters    => [\*(Aqlowercase\*(Aq, \*(Aqalphanumeric\*(Aq]
\&    };
\&    
\&    # a validation rule
\&    field \*(Aquser:login\*(Aq  => {
\&        mixin      => \*(Aqbasic\*(Aq,
\&        label      => \*(Aquser login\*(Aq,
\&        error      => \*(Aqlogin invalid\*(Aq,
\&        validation => sub {
\&            my ($self, $this, $fields) = @_;
\&            return $this\->{value} eq \*(Aqadmin\*(Aq ? 1 : 0;
\&        }
\&    };
\&    
\&    # a validation rule
\&    field \*(Aquser:password\*(Aq  => {
\&        mixin         => \*(Aqbasic\*(Aq,
\&        label         => \*(Aquser login\*(Aq,
\&        error         => \*(Aqlogin invalid\*(Aq,
\&        validation    => sub {
\&            my ($self, $this, $fields) = @_;
\&            return $this\->{value} eq \*(Aqpass\*(Aq ? 1 : 0;
\&        }
\&    };
\&    
\&    1;
.Ve
.SS "\s-1FIELD\s0 \s-1KEYWORD\s0"
.IX Subsection "FIELD KEYWORD"
The field keyword create a validation block and defines validation rules for
reuse in code. The field keyword should correspond with the parameter name
expected to be passed to your validation class.
.PP
.Vb 3
\&    package MyApp::Validation;
\&    use Validation::Class qw/field mixin filter/;
\&    use base \*(AqValidation::Class\*(Aq;
\&    
\&    field \*(Aqlogin\*(Aq => {
\&        required   => 1,
\&        min_length => 1,
\&        max_length => 255,
\&        ...
\&    };
.Ve
.PP
The field keword takes two arguments, the field name and a hashref of key/values
pairs. The keys are referred to as directives, those directives are as follows:
.PP
\fIname\fR
.IX Subsection "name"
.PP
The name of the field (auto set)
.PP
\fIvalue\fR
.IX Subsection "value"
.PP
The value of the parameter matching the name of the field (auto set)
.PP
\fImixin\fR
.IX Subsection "mixin"
.PP
The template to be used to copy directives from e.g.
.PP
.Vb 3
\&    mixin \*(Aqtemplate\*(Aq => {
\&        required => 1
\&    };
\&    
\&    field \*(Aqa_field\*(Aq => {
\&        mixin => \*(Aqtemplate\*(Aq
\&    }
.Ve
.PP
\fImixin_field\fR
.IX Subsection "mixin_field"
.PP
The field to be used as a mixin (template) to have directives copied from e.g.
.PP
.Vb 5
\&    field \*(Aqa_field\*(Aq => {
\&        required => 1,
\&        min_length => 2,
\&        max_length => 10
\&    };
\&    
\&    field \*(Aqb_field\*(Aq => {
\&        mixin_field => \*(Aqa_field\*(Aq
\&    };
.Ve
.PP
\fIvalidation\fR
.IX Subsection "validation"
.PP
A custom validation routine. Please note that the return value is not important.
Please register an error if validation fails e.g.
.PP
.Vb 6
\&    field \*(Aq...\*(Aq => {
\&        validation => sub {
\&            my ($self, $this, $parameters) = @_;
\&            $self\->error($this, "I failed") if $parameters\->{something};
\&        }
\&    };
.Ve
.PP
\fIerrors\fR
.IX Subsection "errors"
.PP
The collection of errors encountered during processing (auto set arrayref)
.PP
\fIlabel\fR
.IX Subsection "label"
.PP
An alias for the field name, something more human-readable, is also used in
auto-generated error messages
.PP
\fIerror\fR
.IX Subsection "error"
.PP
A custom error message, displayed instead of the generic ones
.PP
\fIrequired\fR
.IX Subsection "required"
.PP
Determines whether the field is required or not, takes 1 or 0
.PP
\fImin_length\fR
.IX Subsection "min_length"
.PP
Determines the minimum length of characters allowed
.PP
\fImax_length\fR
.IX Subsection "max_length"
.PP
Determines the maximum length of characters allowed
.PP
\fIref_type\fR
.IX Subsection "ref_type"
.PP
Determines whether the field value is a valid perl reference variable
.PP
\fIregex\fR
.IX Subsection "regex"
.PP
Determines whether the field value passes the supplied regular expression e.g.
.PP
.Vb 9
\&    field \*(Aqc_field\*(Aq => {
\&        label => \*(Aqa field labeled c\*(Aq,
\&        error => \*(Aqa field labeled c cannot be ...\*(Aq,
\&        required => 1,
\&        min_length => 2,
\&        max_length => 25,
\&        ref_type => \*(Aqarray\*(Aq,
\&        regex => \*(Aq^\ed+$\*(Aq
\&    };
.Ve
.PP
\fIfilter\fR
.IX Subsection "filter"
.PP
An alias for the filters directive
.PP
\fIfilters\fR
.IX Subsection "filters"
.PP
Set filters to manipulate the data before validation, e.g.
.PP
.Vb 7
\&    field \*(Aqd_field\*(Aq => {
\&        ...,
\&        filters => [
\&            \*(Aqtrim\*(Aq,
\&            \*(Aqstrip\*(Aq
\&        ]
\&    };
\&    
\&    field \*(Aqe_field\*(Aq => {
\&        filter => \*(Aqstrip\*(Aq
\&    };
\&    
\&    field \*(Aqf_field\*(Aq => {
\&        filters => [
\&            \*(Aqtrim\*(Aq,
\&            sub {
\&                $_[0] =~ s/(abc)|(123)//;
\&            }
\&        ]
\&    };
\&    
\&    # the following filters can be set using the filter(s) keywords:
\&    
\&    field \*(Aqg_field\*(Aq => {
\&        filters => [
\&            \*(Aqtrim\*(Aq, 
\&            \*(Aqalpha\*(Aq,
\&            \*(Aqdigit\*(Aq,
\&            \*(Aqstrip\*(Aq,
\&            \*(Aqnumeric \*(Aq,
\&            \*(Aqlowercase\*(Aq,
\&            \*(Aquppercase\*(Aq,
\&            \*(Aqtitlecase\*(Aq,
\&            \*(Aqcamelcase\*(Aq,
\&            \*(Aqlowercase\*(Aq,
\&            \*(Aqalphanumeric\*(Aq,
\&            sub {
\&                my $value = shift;
\&            }
\&        ]
\&    };
.Ve
.SS "\s-1MIXIN\s0 \s-1KEYWORD\s0"
.IX Subsection "MIXIN KEYWORD"
The mixin keyword creates a validation rules template that can be applied to any
field using the mixin directive.
.PP
.Vb 3
\&    package MyApp::Validation;
\&    use Validation::Class qw/field mixin filter/;
\&    use base \*(AqValidation::Class\*(Aq;
\&    
\&    mixin \*(Aqconstrain\*(Aq => {
\&        required   => 1,
\&        min_length => 1,
\&        max_length => 255,
\&        ...
\&    };
\&    
\&    field \*(Aqlogin\*(Aq => {
\&        mixin => \*(Aqconstrain\*(Aq,
\&        ...
\&    };
.Ve
.SS "\s-1FILTER\s0 \s-1KEYWORD\s0"
.IX Subsection "FILTER KEYWORD"
The filter keyword creates custom filters to be used in your field definitions.
.PP
.Vb 3
\&    package MyApp::Validation;
\&    use Validation::Class qw/field mixin filter/;
\&    10use base \*(AqValidation::Class\*(Aq;
\&    
\&    filter \*(Aqtelephone\*(Aq => sub {
\&        $_[0] =~ s/[^\e(\e)\e\-\e+\es\ed]//g;
\&    };
\&    
\&    field \*(Aqtelephone\*(Aq => {
\&        filter => [\*(Aqtrim\*(Aq, \*(Aqtelephone\*(Aq],
\&        ...
\&    };
.Ve
.SH "EXECUTING A VALIDATION CLASS"
.IX Header "EXECUTING A VALIDATION CLASS"
The following is an example of how to use you constructed validation class in
other code, .e.g. Web App Controller, etc.
.PP
.Vb 1
\&    use MyApp::Validation;
\&    
\&    my $input = MyApp::Validation\->new(params => $params);
\&    unless ($input\->validate(\*(Aqfield1\*(Aq,\*(Aqfield2\*(Aq)){
\&        return $input\->errors\->to_string;
\&    }
.Ve
.PP
Feeling lazy, have your validation class automatically find the appropriate fields
to validate against (params must match field names).
.PP
.Vb 1
\&    use MyApp::Validation;
\&    
\&    my $input = MyApp::Validation\->new(params => $params);
\&    unless ($input\->validate){
\&        return $input\->errors\->to_string;
\&    }
.Ve
.PP
If you are using groups in your validation class you might validate your data
like so ...
.PP
.Vb 1
\&    use MyApp::Validation;
\&    
\&    my $input = MyApp::Validation\->new(params => $params);
\&    unless ($input\->validate(\*(Aquser:login\*(Aq, \*(Aquser:password\*(Aq)){
\&        return $input\->errors\->to_string;
\&    }
.Ve
.PP
Although this means that the incoming parameters need to specify its parameter
names using the same group naming convention. if this is not to your liking,
the \fIvalidate()\fR method can assist you in mapping your incoming parameters to your
defined validation fields as shown here:
.PP
.Vb 1
\&    use MyApp::Validation;
\&    
\&    my $input = MyApp::Validation\->new(params => $params);
\&    unless ($input\->validate({ user => \*(Aquser:login\*(Aq, pass => \*(Aquser:password\*(Aq)){
\&        return $input\->errors\->to_string;
\&    }
.Ve
.SS "new"
.IX Subsection "new"
The new method instantiates and returns an instance of your validation class.
.PP
.Vb 1
\&    use MyApp::Validation;
\&    
\&    my $input = MyApp::Validation\->new;
\&    $input\->params($params);
\&    ...
.Ve
.PP
or
.PP
.Vb 2
\&    my $input = MyApp::Validation\->new(params => $params);
\&    ...
.Ve
.SS "fields"
.IX Subsection "fields"
The fields attribute returns a hashref of defined fields, filtered and merged with
thier parameter counterparts.
.PP
.Vb 2
\&    my $fields = $self\->fields();
\&    ...
.Ve
.SS "filters"
.IX Subsection "filters"
The filters attribute returns a hashref of pre-defined filter definitions.
.PP
.Vb 1
\&    my $filters = $self\->filters();
\&    
\&    $filters\->{trim}\->(...);
\&    $filters\->{alpha}\->(...);
\&    $filters\->{digit}\->(...);
\&    $filters\->{whiteout}\->(...);
\&    $filters\->{numeric}\->(...);
\&    $filters\->{uppercase}\->(...);
\&    $filters\->{titlecase}\->(...);
\&    $filters\->{camelcase}\->(...);
\&    $filters\->{lowercase}\->(...);
\&    $filters\->{alphanumeric}\->(...);
\&    ...
.Ve
.SS "ignore_unknown"
.IX Subsection "ignore_unknown"
The ignore_unknown boolean determines whether your application will live or die
upon encountering unregistered fields during validation.
.PP
.Vb 1
\&    MyApp::Validation\->new(params => $params, ignore_unknown => 1);
\&    
\&    or
\&    
\&    $self\->ignore_unknown(1);
\&    ...
.Ve
.SS "report_unknown"
.IX Subsection "report_unknown"
The report_unknown boolean determines whether your application will report
unregistered fields as class-level errors upon encountering unregistered fields
during validation.
.PP
.Vb 2
\&    MyApp::Validation\->new(params => $params,
\&    ignore_unknown => 1, report_unknown => 1);
\&    
\&    or
\&    
\&    $self\->report_unknown(1);
\&    ...
.Ve
.SS "params"
.IX Subsection "params"
The params attribute gets/sets the parameters to be validated.
.PP
.Vb 3
\&    my $input = {
\&        ...
\&    };
\&    
\&    $self\->params($input);
\&    my $params = $self\->params();
\&    
\&    ...
.Ve
.SS "mixins"
.IX Subsection "mixins"
The mixins attribute returns a hashref of defined validation templates.
.PP
.Vb 2
\&    my $mixins = $self\->mixins();
\&    ...
.Ve
.SS "validate"
.IX Subsection "validate"
The validate method returns a hashref of defined validation templates.
.PP
.Vb 2
\&    my $mixins = $self\->mixins();
\&    ...
.Ve
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
The most important part of any input validation framework is its ease-of-use and
its error handling. Validation::Class gives you the ability to bypass, override
and/or clear errors at-will without a hassle. The following methods assist you in
doing just that.
.SS "error_fields"
.IX Subsection "error_fields"
The error_fields method returns a hashref of fields whose value is an arrayref
of error messages.
.PP
.Vb 3
\&    unless ($self\->validate) {
\&        my $fields = $self\->error_fields();
\&    }
.Ve
.SS "reset_errors"
.IX Subsection "reset_errors"
The reset_errors method clears all errors, both at the class and individual
field levels. This method is called automatically everytime the \fIvalidate()\fR
method is triggered.
.PP
.Vb 1
\&    $self\->reset_errors();
.Ve
.SS "error"
.IX Subsection "error"
The error function is used to set and/or retrieve errors encountered during
validation. The error function with no parameters returns the error message object
which is an arrayref of error messages stored at class-level.
.PP
.Vb 2
\&    # return all errors encountered/set as an arrayref
\&    return $self\->error();
\&    
\&    # return all errors specific to the specified field (at the field\-level)
\&    # as an arrayref
\&    return $self\->error(\*(Aqsome_param\*(Aq);
\&    
\&    # set an error specific to the specified field (at the field\-level)
\&    # using the field object (hashref not field name)
\&    $self\->error($field_object, "i am your error message");
\&
\&    unless ($self\->validate) {
\&        my $fields = $self\->error();
\&    }
.Ve
.SS "errors"
.IX Subsection "errors"
The errors function returns a special class (Validation::Class::Errors) used to
add convenience methods to the error objects. This class can be utilized as
follows.
.PP
.Vb 2
\&    # by default uses errors specified at the class\-level
\&    return $self\->errors;
\&    
\&    # count() method returns the number of errors encoutered
\&    return $self\->errors\->count();
\&    
\&    # to_string($delimiter) method strigifies the error arrayref object using
\&    # the specified delimiter or \*(Aq, \*(Aq by default
\&    return $self\->errors\->to_string();
\&    return $self\->errors\->to_string("<br/>\en");
\&    
\&    # use errors at the field\-level in the errors class
\&    return $self\->errors($self\->fields\->{some_field})\->count();
\&
\&    unless ($self\->validate) {
\&        return $self\->errors\->to_string;
\&    }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Al Newkirk <awncorp@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2010 by awncorp.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
